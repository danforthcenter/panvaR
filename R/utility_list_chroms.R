#' Get Chromosome Names from VCF File
#'
#' @description
#' This function utilizes the 'bcftools index -s' command to extract a list
#' of unique chromosome names present in a given VCF file (can be gzipped).
#' It requires 'bcftools' to be installed and accessible in the system's PATH.
#'
#' @param vcf_file_path character. The file path to the VCF file (e.g., "my_variants.vcf.gz").
#'        The VCF file should ideally be indexed, although `bcftools index -s`
#'        can often generate the index information on the fly if needed.
#'
#' @return A character vector containing the unique chromosome names found in
#'         the VCF file. If `bcftools` encounters an error (e.g., file not found,
#'         invalid format), it prints error messages and returns the captured
#'         standard output/error lines from the system call.
#'
#' @details
#' The function works by executing the following shell command:
#' `bcftools index -s <vcf_file_path>`
#' It captures the standard output of this command, which contains a table
#' where the first column lists the chromosome names. The function then parses
#' this output to return only the unique chromosome names.
#'
#' @examples
#' \dontrun{
#' # Assuming 'my_variants.vcf.gz' exists and bcftools is installed
#' try({
#'   chromosomes <- get_vcf_chromosomes("path/to/your/my_variants.vcf.gz")
#'   print(chromosomes)
#' }, silent = TRUE)
#'
#' # Example with a non-existent file (will show an error message)
#' try({
#'  get_vcf_chromosomes("non_existent_file.vcf.gz")
#' }, silent = TRUE)
#' }
#'
#' @importFrom data.table fread
#' @importFrom sys exec_wait
#' @importFrom dplyr %>% pull
#'
#' @export
get_vcf_chromosomes <- function(vcf_file_path){
  
  # Ensure the file exists before proceeding
  if (!file.exists(vcf_file_path)) {
    stop("Error: The specified VCF file does not exist: ", vcf_file_path)
  }
  
  # Define temporary file path using base R tempfile() for simplicity here
  std_output_name <- tempfile(pattern = "bcf_chroms_")
  error_file_name <- tempfile(pattern = "bcf_error_")
  on.exit({
    # Clean up temporary files when function exits
    if (file.exists(std_output_name)) file.remove(std_output_name)
    if (file.exists(error_file_name)) file.remove(error_file_name)
  })
  
  
  # The shell call that we want to run is:
  # `bcftools index -s <vcf_file_path>`
  binary_call <- "bcftools"
  binary_args <- c(
    "index", "-s",
    vcf_file_path
  )
  
  # Use tryCatch to handle potential errors during the system call
  exit_code <- tryCatch(
    {
      # Execute the command, capturing stdout and stderr
      code <- sys::exec_wait(
        binary_call,
        args = binary_args,
        std_out = std_output_name,
        std_err = error_file_name # Capture errors to a separate file
      )
      code # Return the exit code
    },
    error = function(e){
      # Handle R-level errors during exec_wait setup (less common)
      print(paste("R Error during system call setup:", e$message))
      return(1) # Return a non-zero exit code to indicate failure
    }
  )
  
  #Check the exit code from bcftools
  if (exit_code == 0){
    # Read the standard output generated by bcftools
    tryCatch({
      final_index_table <- data.table::fread(std_output_name, header = FALSE, sep = "\t")
      
      # Check if the table was read correctly and has at least one column
      if (nrow(final_index_table) > 0 && ncol(final_index_table) > 0) {
        # Extract the first column which contains chromosome names
        bcf_chroms <- final_index_table[[1]] # More direct way to get first column
        return(unique(bcf_chroms)) # Return unique chromosome names
      } else {
        warning("bcftools ran successfully, but produced no parsable output.")
        # Read stderr for potential clues if stdout is empty
        error_content <- if (file.exists(error_file_name)) readLines(error_file_name) else "No error output captured."
        print("Error output from bcftools:")
        print(error_content)
        return(character(0)) # Return empty vector
      }
    }, error = function(e) {
      # Handle errors during file reading (e.g., empty file)
      warning("Error reading bcftools output: ", e$message)
      # Read stderr for potential clues
      error_content <- if (file.exists(error_file_name)) readLines(error_file_name) else "No error output captured."
      print("Error output from bcftools:")
      print(error_content)
      return(character(0)) # Return empty vector
    })
    
  } else {
    # bcftools returned an error
    print(paste("Error running bcftools (exit code:", exit_code, "). Please check the messages below:"))
    # Read and print the standard error captured from bcftools
    error_content <- if (file.exists(error_file_name)) readLines(error_file_name) else "No error output captured."
    print(error_content)
    # Optionally, could return the error content or NULL instead of stopping
    return(error_content) # Return the error messages
  }
}